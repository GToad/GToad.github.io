---
layout:     post
title:      "TEE漏洞学习——CVE-2015-6639"
subtitle:   ""
date:       2019-11-26 19:00:00
author:     "GToad"
header-img: "img/android-four.jpg"
catalog: true
tags:
    - TEE
    - trustzone
    - exploit
---

> 最近在看TEE相关内容，顺便把CVE-2015-6639这个QSEE上的著名漏洞看一下。

## 概述

TEE即可信执行环境，全称Trusted Execution Environment。该环境可以保证不被常规的Rich OS（如Windows，Android）干扰，因此是可信的。TEE目前被用于向Rich OS提供各种各样的安全服务。TEE独立于Rich OS上的各种应用，并可以访问硬件和软件安全资源。TEE在x86/x64/ARM/ARM64上都有相关支持与实现，另一个我们比较熟悉的称呼是ARM/ARM64架构手机上的TrustZone。

讲得简单点，现在我们用的Android手机上都有指纹识别，这就需要用到TEE，因为指纹这些生物信息保存在Android系统里的话并不安全，因为手机可能被恶意应用root掉，然后里面的文件都是可以被获取查看的。因此，这就需要把一些非常隐私的数据保存在更加深的地方。

那么有多深呢？以ARM架构的Android系统为例，普通的应用进程运行在EL0层；Android系统包括系统框架、内核等代码运行在EL1层；部分设备还有虚拟化需求，那就需要在EL2层运行hypervisor；而如果要使用TEE相关技术的话，那就需要EL3层运行Secure Monitor，由该层进行安全环境（TEE kernel）与普通环境（Rich OS）的切换。

当前主流的TEE厂商与产品有：Intel的SGX，Qualcomm的QSEE，Huawei HiSilicon的Trusted Core以及Samsung的Kinibi。那么既然TEE能做到如此强的隔离，是不是其中的信息安全就坚不可破了呢？并不是，我们知道，大部分Android手机会使用高通SoC，因此上面运行的TEE Kernel就是QSEE，本文将实践分析一下该TEE产品上出现过的漏洞CVE-2015-6639。

## 基本信息

本漏洞广泛存在于各类使用了高通芯片的Android手机，具体存在于QSEE的widevine中，该模块主要用于实现Widevine DRM以提供安全的媒体播放。我们使用Nexus6手机作为测试手机，因为其属于谷歌Nexus/Pixel系列，可以较容易地进行AOSP编译与root。

## 模块提取

分析漏洞的第一步自然是先获得我们要分析的漏洞模块。该模块在/system/vendor/firmware目录下，用grep命令搜索widevine关键字后获得如下图5个文件。

![](/img/in-post/post-cve20156639/fivewidevine.png)

很显然，该trustlet已经被分成了多个文件，因此我们需要知道其拼装的过程。QSEE为了从“普通环境”中加载trustlet向系统应用程序提供了libQSEECom.so共享对象，输出函数“QSEECom_start_app”：

![](/img/in-post/post-cve20156639/startapp.png)

不过由于大多数TEE相关产品都不开源，因此我们需要逆向分析该.so文件来理解这个加载的过程。本人通过使用IDA Pro对该库文件进行逆向，发现其主要做了如下几件事：

1. 在函数_QSEECom_get_handle中，打开/dev/qseecom设备，并调用一些ioctl函数进行配置
2. 在函数sub_DD0中，打开与trustlet相关的.mdt文件，并读取前0x34字节
3. 在函数sub_DD0中，使用.mdt文件中的0x34字节计算.bXX文件的数量
4. 在函数sub_DD0中，使用ion机制分配一个连续的缓冲区，并将.mdt和.bXX文件复制到其中
5. 在函数sub_DD0中，调用ioctl函数加载trustlet，使用已分配的缓冲区

这看起来就是把这几个文件直接首尾连接起来组装成一个大文件送入TEE，因此依然不清楚该镜像使如何加载的。但是从0x34这个数字依然可以意识到这是个ELF头的大小，于是使用二进制编辑器打开mdt文件，发现前0x34的数据的确是一个ELF头。

![](/img/in-post/post-cve20156639/mdt.png)

此外接下来有连续4个程序头，正好对应了另外四个.bXX文件。其中前两个使NULL类型表示它们是“保留的”，不会被加载入镜像，实际打开.b00和.b01后也发现它们的内容都是mdt文件里已经有的，的确没必要再加载一次。于是就可以写脚本用mdt文件与.b02和.b03恢复出镜像widevine。

