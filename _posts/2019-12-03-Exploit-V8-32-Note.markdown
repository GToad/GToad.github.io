---
layout:     post
title:      "V8引擎1 Day漏洞分析与32位环境利用"
subtitle:   ""
date:       2019-12-3 10:00:00
author:     "GToad"
header-img: "img/android-four.jpg"
catalog: true
tags:
    - V8
    - ARM32
    - exploit
---

> 最近根据一个1 Day信息Pwn了个国产主流旗舰手机，过程中接触了一下32位V8引擎的Exploit过程，做个笔记吧。

## 背景

之前的几篇关于V8引擎的漏洞利用环境都是我在x64架构的Ubuntu16.04上编译的，和32位有区别。而目前可能是为了兼容性，市面上大部分电子设备的浏览器功能依然运行的是ARM32的V8引擎，即便是许多ARMv8的64位旗舰手机也是运行32位的。因此最近在对某个手机进行Pwn的过程中就需要把自己的Exploit适配一下。

最近看到有个1 Day漏洞的信息，链接点[这里](https://bugs.chromium.org/p/project-zero/issues/detail?id=1793)。然后网上也有人写了个针对x64架构的Exploit。不过V8的各种数据结构内部偏移变得很频繁，所以这个[Exploit就当作POC来参考一下](https://github.com/Geluchat/chrome_v8_exploit/blob/master/1793.js)。

## PoC

运行如下代码后b和array就能越界访问之后的内存结构了。

```javascript
array = [];
array.length = 0xffffffff;

b = array.fill(1.1, 0, {valueOf() {
  array.length = 32;
  array.fill(1.1);
  return 0x80000000;
}});
```

## X64下的利用

#### 环境搭建

一开始本次的1 Day漏洞验证环境我使用了之前[CVE-2018-17463漏洞利用](https://gtoad.github.io/2019/09/04/V8-CVE-2018-17463/)的环境，毕竟这个漏洞是2019年的1 Day，看漏洞信息大致猜测是一个持续时间比较长的漏洞，因此2018年末的版本应该是存在的。不过直接使用之前的漏洞验证环境似乎一直无法复现这个漏洞。

![](/img/in-post/post-exploit-v8-32/x64debug.png)

后来发现是由于我之前使用的漏洞验证环境是x64.debug，本次漏洞需要使用release版本才能验证。原因是本次漏洞大致成因是由于length的unsigned类型被错当成了signed，因此大数被当作负数从而导致了后续length处理中产生了OOB问题。而debug版本中存在DCHECK_LE会检测到length变成负数这一现象从而中断引擎的执行。因此本漏洞需要使用release版本或在debug版本中手动去除DCHECK相关检查才能进行验证。

于是我重新编译了x64.release版本，然后成功触发漏洞。

#### 漏洞利用

本漏洞非常容易利用，因为array可以读取下方太多内存空间了，也没什么触发门槛。就用常规思路，先读读object的地址，然后改改arraybuffer的backing_store就可以执行shellcode了。2018以后的V8都用WASM来开辟rwx内存空间进行shellcode的填入。完整exploit如下：

```javascript
由于是1 day漏洞，exploit暂不公开
```



